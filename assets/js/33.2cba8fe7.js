(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{357:function(v,_,a){"use strict";a.r(_);var t=a(0),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"jvm-常问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm-常问"}},[v._v("#")]),v._v(" JVM 常问")]),v._v(" "),a("h2",{attrs:{id:"问题-1-什么是jvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-1-什么是jvm"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 1：什么是JVM？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： Java虚拟机（JVM）是Java编程语言的运行时环境，它负责将Java源代码编译为字节码并执行。它提供了内存管理、垃圾回收、类加载、即时编译等功能。")]),v._v(" "),a("h2",{attrs:{id:"问题-2-jvm的主要组成部分有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-2-jvm的主要组成部分有哪些"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 2：JVM的主要组成部分有哪些？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： JVM由三个主要的子系统组成：类加载器（Class Loader）、运行时数据区（Runtime Data Area）和执行引擎（Execution Engine）。")]),v._v(" "),a("h2",{attrs:{id:"问题-3-jvm的内存模型是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-3-jvm的内存模型是什么"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 3：JVM的内存模型是什么？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： JVM的内存模型分为线程私有区域和线程共享区域。")]),v._v(" "),a("ol",[a("li",[v._v("线程私有区域包括\n"),a("ul",[a("li",[v._v("程序计数器、")]),v._v(" "),a("li",[v._v("虚拟机栈和本地方法栈。")])])]),v._v(" "),a("li",[v._v("线程共享区域包括\n"),a("ul",[a("li",[v._v("堆、")]),v._v(" "),a("li",[v._v("方法区（元空间）和直接内存。")])])])]),v._v(" "),a("h2",{attrs:{id:"问题-4-什么是java堆-它的作用是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-4-什么是java堆-它的作用是什么"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 4：什么是Java堆？它的作用是什么？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： Java堆是存储对象实例的地方，也是垃圾回收的主要区域。所有线程共享堆，它可以分为新生代和老年代，新生代又分为Eden空间、Survivor空间。")]),v._v(" "),a("p",[v._v("老年代是用于存放生命周期较长的对象，经过多次垃圾回收仍然存活的对象会被移到老年代。老年代相对于新生代而言，其垃圾回收频率较低。")]),v._v(" "),a("p",[v._v("这种分代的设计可以优化垃圾回收的效率，将对象按照生命周期进行分类，有助于提高内存利用率和性能。")]),v._v(" "),a("h2",{attrs:{id:"问题-5-java堆中的永久代-permgen-已被废弃-取而代之的是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-5-java堆中的永久代-permgen-已被废弃-取而代之的是什么"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 5：Java堆中的永久代（PermGen）已被废弃，取而代之的是什么？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： Java堆中的永久代已被元空间（Metaspace）取代。元空间存储【类的元数据信息】，如类名、方法、字段等，避免了永久代可能引起的内存溢出问题。")]),v._v(" "),a("h2",{attrs:{id:"问题-6-什么是垃圾回收-garbage-collection-它的目的是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-6-什么是垃圾回收-garbage-collection-它的目的是什么"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 6：什么是垃圾回收（Garbage Collection）？它的目的是什么？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： 垃圾回收是JVM自动管理内存的过程，用于释放不再被引用的对象所占用的内存。其目的是避免内存泄漏，使程序能够有效地使用内存。")]),v._v(" "),a("h2",{attrs:{id:"问题-7-谈谈垃圾回收算法的类型和原理。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-7-谈谈垃圾回收算法的类型和原理。"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 7：谈谈垃圾回收算法的类型和原理。")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： 垃圾回收算法有 标记-清除、复制、标记-整理 等。")]),v._v(" "),a("p",[v._v("其中")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("标记-清除")]),v._v("通过标记不再被引用的对象，然后清除它们；")]),v._v(" "),a("li",[a("strong",[v._v("复制算法")]),v._v("将堆分为两个区域，每次只使用其中一个，将存活对象复制到另一个区域；")]),v._v(" "),a("li",[a("strong",[v._v("标记-整理")]),v._v("通过标记存活对象并整理内存，将存活对象移动到一端，然后清除其余部分。")])]),v._v(" "),a("h2",{attrs:{id:"问题-8-什么是java内存溢出-outofmemoryerror-怎么避免"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-8-什么是java内存溢出-outofmemoryerror-怎么避免"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 8：什么是Java内存溢出（OutOfMemoryError）？怎么避免？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： Java内存溢出是指JVM中没有足够内存分配给新的对象。")]),v._v(" "),a("p",[v._v("可以通过增加堆大小、优化代码、释放不再使用的对象、使用合适的数据结构等方式来避免内存溢出。")]),v._v(" "),a("h2",{attrs:{id:"问题-9-什么是java内存泄漏-如何避免"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-9-什么是java内存泄漏-如何避免"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 9：什么是Java内存泄漏？如何避免？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： Java内存泄漏是指不再使用的对象仍然被保留在内存中，导致内存占用不断增加。")]),v._v(" "),a("p",[v._v("避免内存泄漏的方法包括正确地关闭资源、使用弱引用、及时清除不再使用的引用等。")]),v._v(" "),a("h2",{attrs:{id:"问题-10-什么是类加载器-class-loader-有哪些类加载器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-10-什么是类加载器-class-loader-有哪些类加载器"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 10：什么是类加载器（Class Loader）？有哪些类加载器？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： 类加载器负责将类的字节码加载到JVM中并生成对应的Class对象。主要的类加载器有引导类加载器、扩展类加载器和应用程序类加载器。")]),v._v(" "),a("h2",{attrs:{id:"问题-11-什么是双亲委派模型-parent-delegation-model-它的作用是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-11-什么是双亲委派模型-parent-delegation-model-它的作用是什么"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 11：什么是双亲委派模型（Parent Delegation Model）？它的作用是什么？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("： 双亲委派模型是指类加载器在加载类时首先委派给父类加载器，只有在父类加载器找不到对应的类时才尝试自己加载。这种模型保证了类的一致性和防止类的重复加载。")]),v._v(" "),a("h2",{attrs:{id:"问题-12-什么是类初始化和实例初始化-它们的执行顺序是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-12-什么是类初始化和实例初始化-它们的执行顺序是怎样的"}},[v._v("#")]),v._v(" "),a("em",[v._v("问题 12：什么是类初始化和实例初始化？它们的执行顺序是怎样的？")])]),v._v(" "),a("p",[a("strong",[v._v("答案")]),v._v("：")]),v._v(" "),a("ul",[a("li",[v._v("类初始化是在类加载过程中执行的静态初始化代码块，")]),v._v(" "),a("li",[v._v("实例初始化是在创建对象时执行的实例初始化代码块。")])]),v._v(" "),a("p",[v._v("类初始化在类加载过程中只执行一次，实例初始化在每次创建对象时都会执行。")]),v._v(" "),a("p",[v._v("执行顺序是：父类的类初始化 -> 子类的类初始化 -> 父类的实例初始化 -> 子类的实例初始化。")]),v._v(" "),a("h2",{attrs:{id:"面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[v._v("#")]),v._v(" 面试题")]),v._v(" "),a("h3",{attrs:{id:"jvm-内存区域划分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内存区域划分"}},[v._v("#")]),v._v(" JVM 内存区域划分")]),v._v(" "),a("ul",[a("li",[v._v("介绍 JVM 内存区域的划分，包括堆、方法区（元空间）、栈、本地方法栈和程序计数器。")]),v._v(" "),a("li",[v._v("详细解释堆内存和方法区（元空间）的作用和区别。")]),v._v(" "),a("li",[v._v("什么是永久代（PermGen）？Java 8 及以后版本的 JVM 有何不同？")])]),v._v(" "),a("h3",{attrs:{id:"类加载机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载机制"}},[v._v("#")]),v._v(" 类加载机制")]),v._v(" "),a("ul",[a("li",[v._v("什么是类加载器？Java 中有哪些内置的类加载器？")]),v._v(" "),a("li",[v._v("解释类加载的双亲委派模型。")]),v._v(" "),a("li",[v._v("什么是类加载过程，包括加载、连接和初始化阶段。")]),v._v(" "),a("li",[v._v("什么是类加载器的委托机制？")])]),v._v(" "),a("h3",{attrs:{id:"对象创建过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象创建过程"}},[v._v("#")]),v._v(" 对象创建过程")]),v._v(" "),a("ul",[a("li",[v._v("描述对象的创建过程，包括对象的内存分配和初始化。")]),v._v(" "),a("li",[v._v("什么是对象头，它包含哪些信息？")]),v._v(" "),a("li",[v._v("如何优化对象的创建，例如使用对象池或延迟初始化？")])]),v._v(" "),a("h3",{attrs:{id:"垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[v._v("#")]),v._v(" 垃圾回收算法")]),v._v(" "),a("ul",[a("li",[v._v("解释垃圾回收的目的和原理。")]),v._v(" "),a("li",[v._v("介绍常见的垃圾回收算法，如标记-清除、复制、标记-整理等。")]),v._v(" "),a("li",[v._v("什么是分代垃圾回收，为什么要使用它？")]),v._v(" "),a("li",[v._v("解释新生代和老年代之间的对象流动和垃圾回收策略。")])]),v._v(" "),a("h3",{attrs:{id:"常见的垃圾收集器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的垃圾收集器"}},[v._v("#")]),v._v(" 常见的垃圾收集器")]),v._v(" "),a("ul",[a("li",[v._v("描述并区分常见的垃圾收集器，如Serial GC、Parallel GC、CMS、G1 等。")]),v._v(" "),a("li",[v._v("针对不同应用场景，哪个垃圾收集器更适合使用？")])]),v._v(" "),a("h3",{attrs:{id:"jvm-调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm-调优"}},[v._v("#")]),v._v(" JVM 调优")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("如何监控 JVM 的性能和内存使用情况？")])]),v._v(" "),a("li",[a("p",[v._v("什么是垃圾回收日志（GC 日志）？如何分析它来优化应用程序性能？")])]),v._v(" "),a("li",[a("p",[v._v("介绍 JVM 参数（例如-Xmx、-Xms、-XX、-Xss）的作用和用法。")])]),v._v(" "),a("li",[a("p",[v._v("现在我有一个服务，部署后分配了 4g 的堆内存，请从你的角度来分析下怎么优化 jvm")]),v._v(" "),a("p",[v._v("为了优化 JVM 性能，您可以考虑以下几个关键方面：合理配置堆内存大小、"),a("strong",[v._v("选择适当的垃圾回收器和策略")]),v._v("、精心管理线程和类加载、"),a("strong",[v._v("优化代码和资源使用")]),v._v("、"),a("strong",[v._v("并发控制")]),v._v("、实时监控和分析性能，以及定期升级 JVM 版本。")])])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("内存分配")]),v._v("：\n"),a("ul",[a("li",[a("strong",[v._v("堆内存大小")]),v._v("：根据应用程序的需求和服务器的资源，合理设置堆内存大小。通常，不要将堆内存设置得过大，以避免过长的垃圾回收停顿时间。建议使用Xmx和Xms参数来配置堆内存大小。")])])]),v._v(" "),a("li",[a("strong",[v._v("垃圾回收")]),v._v("：\n"),a("ul",[a("li",[a("strong",[v._v("选择合适的垃圾回收器")]),v._v("：根据应用程序的性质和需求，选择合适的垃圾回收器。例如，G1垃圾回收器适用于具有大堆内存的应用程序，而CMS适用于低延迟要求的应用程序。")]),v._v(" "),a("li",[a("strong",[v._v("调整垃圾回收策略")]),v._v("：根据应用程序的内存使用情况，可以调整垃圾回收策略的参数，如新生代和老年代的比例、GC停顿时间等。")]),v._v(" "),a("li",[a("strong",[v._v("监控垃圾回收")]),v._v("：使用JVM的垃圾回收日志和工具（如VisualVM、Grafana、Prometheus）来监控垃圾回收性能，及时发现问题并进行调整。")])])]),v._v(" "),a("li",[a("strong",[v._v("线程管理")]),v._v("：\n"),a("ul",[a("li",[a("strong",[v._v("控制线程数量")]),v._v("：合理控制应用程序中的线程数量，以避免线程过多导致内存和CPU资源的浪费。")]),v._v(" "),a("li",[a("strong",[v._v("使用线程池")]),v._v("：使用线程池来管理线程，以避免线程的频繁创建和销毁。")])])]),v._v(" "),a("li",[a("strong",[v._v("类加载优化")]),v._v("：\n"),a("ul",[a("li",[a("strong",[v._v("预热类加载")]),v._v("：通过预热（Warm-Up）机制，在应用程序启动之前加载一些常用的类，提高应用程序的启动性能。")]),v._v(" "),a("li",[a("strong",[v._v("避免不必要的类加载")]),v._v("：避免不必要的动态类加载操作，减少类加载器的负担。")])])]),v._v(" "),a("li",[a("strong",[v._v("代码优化")]),v._v("：\n"),a("ul",[a("li",[a("strong",[v._v("避免过多的对象创建")]),v._v("：减少对象的创建和销毁，尤其是在循环中。")]),v._v(" "),a("li",[a("strong",[v._v("优化算法")]),v._v("：选择高效的算法和数据结构，避免性能低下的操作。")])])]),v._v(" "),a("li",[a("strong",[v._v("资源管理")]),v._v("：\n"),a("ul",[a("li",[a("strong",[v._v("关闭不需要的资源")]),v._v("：及时关闭文件、数据库连接、网络连接等资源，以释放系统资源。")]),v._v(" "),a("li",[a("strong",[v._v("使用连接池")]),v._v("：使用数据库连接池、连接池等资源池，以便有效地管理和复用资源。")])])]),v._v(" "),a("li",[a("strong",[v._v("并发管理")]),v._v("：\n"),a("ul",[a("li",[a("strong",[v._v("使用并发工具")]),v._v("：使用Java的并发工具库，如ConcurrentHashMap、线程池，来管理并发访问。")]),v._v(" "),a("li",[a("strong",[v._v("避免竞态条件")]),v._v("：使用锁和同步机制来避免多线程竞态条件导致的问题。")])])]),v._v(" "),a("li",[a("strong",[v._v("监控和分析")]),v._v("：\n"),a("ul",[a("li",[a("strong",[v._v("实时监控")]),v._v("：使用监控工具来实时监控应用程序的性能指标，及时发现问题。")]),v._v(" "),a("li",[a("strong",[v._v("分析工具")]),v._v("：使用性能分析工具来识别性能瓶颈和内存泄漏问题。")])])]),v._v(" "),a("li",[a("strong",[v._v("版本升级")]),v._v("：\n"),a("ul",[a("li",[a("strong",[v._v("JVM版本")]),v._v("：升级到最新的JVM版本，以获取性能和安全性的改进。")])])]),v._v(" "),a("li",[a("strong",[v._v("容器化")]),v._v("：\n"),a("ul",[a("li",[v._v("如果应用程序运行在容器中，合理配置容器的资源限制，以避免资源争用。")])])])])])}),[],!1,null,null,null);_.default=r.exports}}]);