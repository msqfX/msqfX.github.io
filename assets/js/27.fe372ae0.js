(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{353:function(v,_,t){"use strict";t.r(_);var r=t(0),a=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"锁详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁详解"}},[v._v("#")]),v._v(" 锁详解")]),v._v(" "),t("h2",{attrs:{id:"死锁问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁问题"}},[v._v("#")]),v._v(" 死锁问题")]),v._v(" "),t("h3",{attrs:{id:"什么是线程死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程死锁"}},[v._v("#")]),v._v(" 什么是线程死锁?")]),v._v(" "),t("p",[v._v("线程死锁是指：两个或多个线程互相持有对方所需要的资源而互相等待的状态，导致程序无法继续执行下去，进而陷入死循环，无法完成任务。")]),v._v(" "),t("h3",{attrs:{id:"死锁产生的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁产生的原因"}},[v._v("#")]),v._v(" 死锁产生的原因")]),v._v(" "),t("p",[v._v("通常情况下，线程死锁产生的原因是: "),t("strong",[v._v("两个或多个线程对资源的竞争和不当的资源分配")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"死锁产生的条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁产生的条件"}},[v._v("#")]),v._v(" 死锁产生的条件")]),v._v(" "),t("p",[v._v("线程死锁的产生通常需要"),t("strong",[v._v("同时满足以下四个条件")]),v._v("：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("互斥条件")]),v._v("：该资源任意一个时刻只由一个线程占用。")]),v._v(" "),t("li",[t("strong",[v._v("请求与保持条件")]),v._v("：一个线程因请求资源而阻塞时，对已获得的资源保持不放。")]),v._v(" "),t("li",[t("strong",[v._v("不剥夺条件")]),v._v("：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。")]),v._v(" "),t("li",[t("strong",[v._v("循环等待条件")]),v._v(": 若干线程之间形成一种头尾相接的循环等待资源关系。")])]),v._v(" "),t("h3",{attrs:{id:"如何预防死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何预防死锁"}},[v._v("#")]),v._v(" 如何预防死锁？")]),v._v(" "),t("p",[v._v("预防死锁只要破坏死锁产生的必要条件即可：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("破坏请求与保持条件")]),v._v("：一次性申请所有的资源。")]),v._v(" "),t("li",[t("strong",[v._v("破坏不剥夺条件")]),v._v("：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。")]),v._v(" "),t("li",[t("strong",[v._v("破坏循环等待条件")]),v._v("：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。")])]),v._v(" "),t("h3",{attrs:{id:"如何避免死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何避免死锁"}},[v._v("#")]),v._v(" 如何避免死锁？")]),v._v(" "),t("p",[v._v("避免死锁就是"),t("strong",[v._v("在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"乐观锁和悲观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁和悲观锁"}},[v._v("#")]),v._v(" 乐观锁和悲观锁")]),v._v(" "),t("h3",{attrs:{id:"什么是乐观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是乐观锁"}},[v._v("#")]),v._v(" 什么是乐观锁？")]),v._v(" "),t("p",[v._v("乐观锁总是假设最好的情况，"),t("strong",[v._v("认为共享资源每次被访问的时候不会出现问题")]),v._v("，线程可以不停地执行，"),t("strong",[v._v("无需加锁也无需等待")]),v._v("，只是在提交修改的时候去验证对应的资源是否被其它线程修改了。")]),v._v(" "),t("p",[t("em",[t("strong",[v._v("优点")])])]),v._v(" "),t("p",[v._v("不会造成线程阻塞")]),v._v(" "),t("p",[t("em",[t("strong",[v._v("缺点")])])]),v._v(" "),t("p",[v._v("在并发更新的情况下，可能会出现 ABA 问题，需要使用版本号或时间戳等机制来解决。")]),v._v(" "),t("blockquote",[t("p",[v._v("ABA 问题是: 在使用 CAS 算法时可能出现的一个问题。")]),v._v(" "),t("p",[v._v("它的本质是: 由于线程之间的竞争，导致共享数据的值在某个时间点被修改为 A，然后又被修改为 B，最后再被修改回 A，")]),v._v(" "),t("p",[v._v("这时候使用 CAS 算法时，比较的是共享数据的值是否等于 A，如果等于 A，则执行操作，但"),t("strong",[v._v("实际上共享数据的值已经被修改过了")]),v._v("。")]),v._v(" "),t("p",[v._v("简单来说，就是在使用 CAS 算法的时候发生了误判。")])]),v._v(" "),t("p",[t("em",[t("strong",[v._v("典型代表")])])]),v._v(" "),t("p",[v._v("比如：使用版本号机制、CAS 算法")]),v._v(" "),t("h3",{attrs:{id:"什么是悲观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是悲观锁"}},[v._v("#")]),v._v(" 什么是悲观锁？")]),v._v(" "),t("p",[v._v("悲观锁总是假设最坏的情况，"),t("strong",[v._v("认为共享资源每次被访问的时候就会出现问题")]),v._v("(比如共享数据被修改)，所以"),t("strong",[v._v("每次在获取资源操作的时候都会上锁")]),v._v("，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。")]),v._v(" "),t("p",[t("em",[t("strong",[v._v("优点")])])]),v._v(" "),t("p",[v._v("安全，能够保证数据操作的正确性和一致性。")]),v._v(" "),t("p",[t("em",[t("strong",[v._v("缺点")])])]),v._v(" "),t("p",[v._v("悲观锁的缺点是在高并发的情况下，会造成大量的线程阻塞，降低系统的性能。")]),v._v(" "),t("p",[t("em",[t("strong",[v._v("典型代表")])])]),v._v(" "),t("p",[v._v("比如：Java 中 的 "),t("code",[v._v("synchronized")]),v._v(" 和 "),t("code",[v._v("ReentrantLock")]),v._v(" 等独占锁，数据库中的行级锁和表级锁。")]),v._v(" "),t("h3",{attrs:{id:"如何实现乐观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何实现乐观锁"}},[v._v("#")]),v._v(" 如何实现乐观锁？")]),v._v(" "),t("h4",{attrs:{id:"版本控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#版本控制"}},[v._v("#")]),v._v(" 版本控制")]),v._v(" "),t("p",[v._v("在操作共享资源之前，先读取数据的版本号，然后将操作结果与当前版本号进行比较，如果版本号一致，则可以进行操作，如果版本号不一致，则说明数据已被其他线程修改，需要回滚并重试。")]),v._v(" "),t("h4",{attrs:{id:"cas-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas-算法"}},[v._v("#")]),v._v(" CAS 算法")]),v._v(" "),t("p",[v._v("CAS 的全称是 "),t("strong",[v._v("Compare And Swap（比较与交换）")]),v._v("，用于实现乐观锁，被广泛应用于各大框架中。")]),v._v(" "),t("p",[v._v("CAS 的思想很简单，"),t("strong",[v._v("就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新")]),v._v("。")]),v._v(" "),t("p",[v._v("是一个原子操作，底层依赖于一条 CPU 的原子指令。")]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("原子操作")]),v._v(" 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。")])]),v._v(" "),t("h3",{attrs:{id:"如何实现悲观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何实现悲观锁"}},[v._v("#")]),v._v(" 如何实现悲观锁？")]),v._v(" "),t("p",[v._v("悲观锁的实现方式主要有两种：基于数据库的悲观锁和基于代码的悲观锁。")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("基于数据库的悲观锁")])]),v._v(" "),t("p",[v._v("基于数据库的悲观锁是通过"),t("strong",[v._v("数据库的锁机制")]),v._v("来实现的。在数据库中，可以通过 "),t("code",[v._v("SELECT ... FOR UPDATE")]),v._v(" 语句或 "),t("code",[v._v("SELECT ... FOR SHARE")]),v._v(" 语句来获取悲观锁。")]),v._v(" "),t("ul",[t("li",[v._v("当一个事务执行 "),t("code",[v._v("SELECT ... FOR UPDATE")]),v._v(" 语句时，数据库会将所选的行加上"),t("strong",[v._v("排他锁")]),v._v("，其他事务"),t("strong",[v._v("不能修改")]),v._v("这些行；")]),v._v(" "),t("li",[v._v("当一个事务执行 "),t("code",[v._v("SELECT ... FOR SHARE")]),v._v(" 语句时，数据库会将所选的行加上"),t("strong",[v._v("共享锁")]),v._v("，其他事务"),t("strong",[v._v("只能读取")]),v._v("这些行，不能修改。在使用完锁后，需要及时释放锁，避免长时间占用数据库资源。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("基于代码的悲观锁")])]),v._v(" "),t("p",[v._v("基于代码的悲观锁是通过程序代码来实现的。在 Java 中，"),t("strong",[v._v("可以使用 "),t("code",[v._v("synchronized")]),v._v(" 关键字或 "),t("code",[v._v("Lock")]),v._v(" 接口来实现悲观锁")]),v._v("。")]),v._v(" "),t("ul",[t("li",[v._v("使用 "),t("code",[v._v("synchronized")]),v._v(" 关键字时，需要"),t("strong",[v._v("在方法或代码块上加锁")]),v._v("，以确保同一时间只有一个线程可以执行这段代码；")]),v._v(" "),t("li",[v._v("使用 "),t("code",[v._v("Lock")]),v._v(" 接口时，需要先获取锁（"),t("strong",[v._v("调用 "),t("code",[v._v("lock()")]),v._v(" 方法")]),v._v("），然后执行操作，最后释放锁（调用 "),t("strong",[t("code",[v._v("unlock()")]),v._v(" 方法")]),v._v("），以确保同一时间只有一个线程可以操作共享资源。")])])])]),v._v(" "),t("h2",{attrs:{id:"学习参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#学习参考"}},[v._v("#")]),v._v(" 学习参考")]),v._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("Java并发常见面试题总结（中） | JavaGuide(Java面试 + 学习指南)"),t("OutboundLink")],1)])]),v._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://www.sharkchili.com/pages/ad63b9/",target:"_blank",rel:"noopener noreferrer"}},[v._v("JUC包下各种锁使用详解 | Shark Chili"),t("OutboundLink")],1)])])])])}),[],!1,null,null,null);_.default=a.exports}}]);