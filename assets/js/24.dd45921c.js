(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{355:function(v,_,e){"use strict";e.r(_);var t=e(0),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"queue-集合详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#queue-集合详解"}},[v._v("#")]),v._v(" Queue 集合详解")]),v._v(" "),e("h2",{attrs:{id:"queue-与-deque-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#queue-与-deque-的区别"}},[v._v("#")]),v._v(" Queue 与 Deque 的区别")]),v._v(" "),e("p",[e("code",[v._v("Queue")]),v._v(" 是"),e("strong",[v._v("单端队列")]),v._v("，只能从一端插入元素，另一端删除元素，实现上一般遵循 "),e("strong",[v._v("先进先出（FIFO）")]),v._v(" 规则。")]),v._v(" "),e("p",[e("code",[v._v("Queue")]),v._v(" 扩展了 "),e("code",[v._v("Collection")]),v._v(" 的接口，根据 "),e("strong",[v._v("因为容量问题而导致操作失败后处理方式的不同")]),v._v(" 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[e("code",[v._v("Queue")]),v._v(" 接口")]),v._v(" "),e("th",[v._v("抛出异常")]),v._v(" "),e("th",[v._v("返回特殊值")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("插入队尾")]),v._v(" "),e("td",[v._v("add(E e)")]),v._v(" "),e("td",[v._v("offer(E e)")])]),v._v(" "),e("tr",[e("td",[v._v("删除队首")]),v._v(" "),e("td",[v._v("remove()")]),v._v(" "),e("td",[v._v("poll()")])]),v._v(" "),e("tr",[e("td",[v._v("查询队首元素")]),v._v(" "),e("td",[v._v("element()")]),v._v(" "),e("td",[v._v("peek()")])])])]),v._v(" "),e("p",[e("code",[v._v("Deque")]),v._v(" 是"),e("strong",[v._v("双端队列")]),v._v("，在队列的两端均可以插入或删除元素。")]),v._v(" "),e("p",[e("code",[v._v("Deque")]),v._v(" 扩展了 "),e("code",[v._v("Queue")]),v._v(" 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[e("code",[v._v("Deque")]),v._v(" 接口")]),v._v(" "),e("th",[v._v("抛出异常")]),v._v(" "),e("th",[v._v("返回特殊值")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("插入队首")]),v._v(" "),e("td",[v._v("addFirst(E e)")]),v._v(" "),e("td",[v._v("offerFirst(E e)")])]),v._v(" "),e("tr",[e("td",[v._v("插入队尾")]),v._v(" "),e("td",[v._v("addLast(E e)")]),v._v(" "),e("td",[v._v("offerLast(E e)")])]),v._v(" "),e("tr",[e("td",[v._v("删除队首")]),v._v(" "),e("td",[v._v("removeFirst()")]),v._v(" "),e("td",[v._v("pollFirst()")])]),v._v(" "),e("tr",[e("td",[v._v("删除队尾")]),v._v(" "),e("td",[v._v("removeLast()")]),v._v(" "),e("td",[v._v("pollLast()")])]),v._v(" "),e("tr",[e("td",[v._v("查询队首元素")]),v._v(" "),e("td",[v._v("getFirst()")]),v._v(" "),e("td",[v._v("peekFirst()")])]),v._v(" "),e("tr",[e("td",[v._v("查询队尾元素")]),v._v(" "),e("td",[v._v("getLast()")]),v._v(" "),e("td",[v._v("peekLast()")])])])]),v._v(" "),e("p",[v._v("事实上，"),e("code",[v._v("Deque")]),v._v(" 还提供有 "),e("code",[v._v("push()")]),v._v(" 和 "),e("code",[v._v("pop()")]),v._v(" 等其他方法，可用于模拟栈。")]),v._v(" "),e("h2",{attrs:{id:"arraydeque-与-linkedlist-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#arraydeque-与-linkedlist-的区别"}},[v._v("#")]),v._v(" ArrayDeque 与 LinkedList 的区别")]),v._v(" "),e("p",[e("code",[v._v("ArrayDeque")]),v._v(" 和 "),e("code",[v._v("LinkedList")]),v._v(" 都实现了 "),e("code",[v._v("Deque")]),v._v(" 接口，两者"),e("strong",[v._v("都具有队列的功能")]),v._v("，但两者有什么区别呢？")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("ArrayDeque")]),v._v(" 是"),e("strong",[v._v("基于可变长的数组和双指针")]),v._v("来实现，而 "),e("code",[v._v("LinkedList")]),v._v(" 则通过"),e("strong",[v._v("链表")]),v._v("来实现。")]),v._v(" "),e("li",[e("code",[v._v("ArrayDeque")]),v._v(" 不支持存储 "),e("code",[v._v("NULL")]),v._v(" 数据，但 "),e("code",[v._v("LinkedList")]),v._v(" 支持。")]),v._v(" "),e("li",[e("code",[v._v("ArrayDeque")]),v._v(" 是在 JDK1.6 才被引入的，而"),e("code",[v._v("LinkedList")]),v._v(" 早在 JDK1.2 时就已经存在。")]),v._v(" "),e("li",[e("code",[v._v("ArrayDeque")]),v._v(" 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 "),e("code",[v._v("LinkedList")]),v._v(" 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。")])]),v._v(" "),e("blockquote",[e("p",[v._v("从性能的角度上，选用 "),e("code",[v._v("ArrayDeque")]),v._v(" 来实现队列要比 "),e("code",[v._v("LinkedList")]),v._v(" 更好。此外，"),e("code",[v._v("ArrayDeque")]),v._v(" 也可以用于实现栈。")])]),v._v(" "),e("h2",{attrs:{id:"说一说-priorityqueue-优先级队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一说-priorityqueue-优先级队列"}},[v._v("#")]),v._v(" 说一说 PriorityQueue（优先级队列）")]),v._v(" "),e("p",[e("code",[v._v("PriorityQueue")]),v._v(" 是在 JDK1.5 中被引入的, 其与 "),e("code",[v._v("Queue")]),v._v(" 的"),e("strong",[v._v("区别在于")]),v._v("元素出队顺序是与优先级相关的，即"),e("strong",[v._v("总是优先级最高的元素先出队")]),v._v("。")]),v._v(" "),e("p",[v._v("这里列举其相关的一些要点：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("PriorityQueue")]),v._v(" 利用了"),e("strong",[v._v("二叉堆的数据结构")]),v._v("来"),e("strong",[v._v("实现")]),v._v("的，底层"),e("strong",[v._v("使用可变长的数组来存储数据")])]),v._v(" "),e("li",[e("code",[v._v("PriorityQueue")]),v._v(" 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。")]),v._v(" "),e("li",[e("code",[v._v("PriorityQueue")]),v._v(" 是"),e("strong",[v._v("非线程安全")]),v._v("的，且不支持存储 "),e("code",[v._v("NULL")]),v._v(" 和 "),e("code",[v._v("non-comparable")]),v._v(" 的对象。")]),v._v(" "),e("li",[e("code",[v._v("PriorityQueue")]),v._v(" "),e("strong",[v._v("默认是小顶堆")]),v._v("，但可以接收一个 "),e("code",[v._v("Comparator")]),v._v(" 作为构造参数，从而来自定义元素优先级的先后。")])]),v._v(" "),e("blockquote",[e("p",[v._v("二叉堆（binary heap）是一种基于完全二叉树的数据结构，它满足如下两个性质：")]),v._v(" "),e("ol",[e("li",[v._v("父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。")]),v._v(" "),e("li",[v._v("每个节点的左子树和右子树都是一个二叉堆（称为堆的性质）。 根据性质1，我们可以将二叉堆划分为两种类型：最大堆和最小堆。")])]),v._v(" "),e("ul",[e("li",[v._v("在最大堆中，父节点的键值总是"),e("strong",[v._v("大于或等于")]),v._v("任何一个子节点的键值。")]),v._v(" "),e("li",[v._v("在最小堆中，父节点的键值总是"),e("strong",[v._v("小于或等于")]),v._v("任何一个子节点的键值。")])]),v._v(" "),e("p",[e("code",[v._v("PriorityQueue")]),v._v(" 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);